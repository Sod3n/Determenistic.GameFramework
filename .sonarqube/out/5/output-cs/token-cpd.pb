ô¸
†/Users/a1/Documents/GitHub/turn-based-prototype/Server/Framework/Deterministic.GameFramework.SourceGenerators/GameDataEnumGenerator.cs
	namespace 	
Deterministic
 
. 
GameFramework %
.% &
SourceGenerators& 6
;6 7
[ 
	Generator 

]
 
public		 
class		 !
GameDataEnumGenerator		 "
:		# $!
IIncrementalGenerator		% :
{

 
public 

void 

Initialize 
( 5
)IncrementalGeneratorInitializationContext D
contextE L
)L M
{ 
var 

configFile 
= 
context  
.  !#
AdditionalTextsProvider! 8
. 
Where 
( 
file 
=> 
file 
.  
Path  $
.$ %
EndsWith% -
(- .
$str. C
)C D
)D E
. 
Select 
( 
static 
( 
file  
,  !
_" #
)# $
=>% '
file( ,
), -
;- .
var 
	jsonFiles 
= 
context 
.  #
AdditionalTextsProvider  7
. 
Where 
( 
file 
=> 
file 
.  
Path  $
.$ %
EndsWith% -
(- .
$str. 5
)5 6
&&7 9
!: ;
file; ?
.? @
Path@ D
.D E
EndsWithE M
(M N
$strN c
)c d
)d e
;e f
var 
combined 
= 

configFile !
.! "
Combine" )
() *
	jsonFiles* 3
.3 4
Collect4 ;
(; <
)< =
)= >
;> ?
context 
.  
RegisterSourceOutput $
($ %
combined% -
,- .
static/ 5
(6 7
spc7 :
,: ;
source< B
)B C
=>D F
ExecuteG N
(N O
spcO R
,R S
sourceT Z
.Z [
Left[ _
,_ `
sourcea g
.g h
Righth m
)m n
)n o
;o p
} 
private 
static 
void 
Execute 
(  #
SourceProductionContext  7
context8 ?
,? @
AdditionalTextA O
?O P

configFileQ [
,[ \
ImmutableArray] k
<k l
AdditionalTextl z
>z {
	jsonFiles	| …
)
… †
{ 
if 

( 

configFile 
== 
null 
) 
{ 	
context   
.   
ReportDiagnostic   $
(  $ %

Diagnostic  % /
.  / 0
Create  0 6
(  6 7
new!!  
DiagnosticDescriptor!! (
(!!( )
$str"" 
,"" 
$str## +
,##+ ,
$str$$ =
,$$= >
$str%% +
,%%+ ,
DiagnosticSeverity&& &
.&&& '
Error&&' ,
,&&, -
true'' 
)'' 
,'' 
Location(( 
.(( 
None(( 
)(( 
)(( 
;((  
return)) 
;)) 
}** 	
try,, 
{-- 	
var// 
configContent// 
=// 

configFile//  *
.//* +
GetText//+ 2
(//2 3
)//3 4
?//4 5
.//5 6
ToString//6 >
(//> ?
)//? @
;//@ A
if00 
(00 
string00 
.00 
IsNullOrEmpty00 $
(00$ %
configContent00% 2
)002 3
)003 4
return11 
;11 
var44 
enumConfigs44 
=44 
ParseEnumConfig44 -
(44- .
configContent44. ;
)44; <
;44< =
foreach77 
(77 
var77 

enumConfig77 #
in77$ &
enumConfigs77' 2
)772 3
{88 
GenerateEnum99 
(99 
context99 $
,99$ %

enumConfig99& 0
,990 1
	jsonFiles992 ;
)99; <
;99< =
}:: 
};; 	
catch<< 
(<< 
	Exception<< 
ex<< 
)<< 
{== 	
context>> 
.>> 
ReportDiagnostic>> $
(>>$ %

Diagnostic>>% /
.>>/ 0
Create>>0 6
(>>6 7
new??  
DiagnosticDescriptor?? (
(??( )
$str@@ 
,@@ 
$strAA %
,AA% &
$"BB 
$strBB 8
{BB8 9
exBB9 ;
.BB; <
MessageBB< C
}BBC D
"BBD E
,BBE F
$strCC +
,CC+ ,
DiagnosticSeverityDD &
.DD& '
ErrorDD' ,
,DD, -
trueEE 
)EE 
,EE 
LocationFF 
.FF 
NoneFF 
)FF 
)FF 
;FF  
}GG 	
}HH 
privateJJ 
staticJJ 
ListJJ 
<JJ 

EnumConfigJJ "
>JJ" #
ParseEnumConfigJJ$ 3
(JJ3 4
stringJJ4 :
configContentJJ; H
)JJH I
{KK 
varLL 
configsLL 
=LL 
newLL 
ListLL 
<LL 

EnumConfigLL )
>LL) *
(LL* +
)LL+ ,
;LL, -
varOO 
patternOO 
=OO 
$strOO s
;OOs t
varPP 
matchesPP 
=PP 
RegexPP 
.PP 
MatchesPP #
(PP# $
configContentPP$ 1
,PP1 2
patternPP3 :
)PP: ;
;PP; <
foreachRR 
(RR 
MatchRR 
matchRR 
inRR 
matchesRR  '
)RR' (
{SS 	
ifTT 
(TT 
matchTT 
.TT 
GroupsTT 
.TT 
CountTT "
>=TT# %
$numTT& '
)TT' (
{UU 
configsVV 
.VV 
AddVV 
(VV 
newVV 

EnumConfigVV  *
(VV* +
matchWW 
.WW 
GroupsWW  
[WW  !
$numWW! "
]WW" #
.WW# $
ValueWW$ )
,WW) *
matchXX 
.XX 
GroupsXX  
[XX  !
$numXX! "
]XX" #
.XX# $
ValueXX$ )
,XX) *
matchYY 
.YY 
GroupsYY  
[YY  !
$numYY! "
]YY" #
.YY# $
ValueYY$ )
)ZZ 
)ZZ 
;ZZ 
}[[ 
}\\ 	
return^^ 
configs^^ 
;^^ 
}__ 
privateaa 
staticaa 
voidaa 
GenerateEnumaa $
(aa$ %#
SourceProductionContextaa% <
contextaa= D
,aaD E

EnumConfigaaF P

enumConfigaaQ [
,aa[ \
ImmutableArrayaa] k
<aak l
AdditionalTextaal z
>aaz {
	jsonFiles	aa| …
)
aa… †
{bb 
vardd 
jsonFiledd 
=dd 
FindJsonFiledd #
(dd# $
	jsonFilesdd$ -
,dd- .

enumConfigdd/ 9
.dd9 :
Sourcedd: @
)dd@ A
;ddA B
ifff 

(ff 
jsonFileff 
==ff 
nullff 
)ff 
{gg 	
contexthh 
.hh 
ReportDiagnostichh $
(hh$ %

Diagnostichh% /
.hh/ 0
Createhh0 6
(hh6 7
newii  
DiagnosticDescriptorii (
(ii( )
$strjj 
,jj 
$strkk )
,kk) *
$"ll 
$strll ;
{ll; <

enumConfigll< F
.llF G
SourcellG M
}llM N
$strllN W
{llW X

enumConfigllX b
.llb c
EnumNamellc k
}llk l
$strlll n
"lln o
,llo p
$strmm +
,mm+ ,
DiagnosticSeveritynn &
.nn& '
Errornn' ,
,nn, -
trueoo 
)oo 
,oo 
Locationpp 
.pp 
Nonepp 
)pp 
)pp 
;pp  
returnqq 
;qq 
}rr 	
varuu 
jsonContentuu 
=uu 
jsonFileuu "
.uu" #
GetTextuu# *
(uu* +
)uu+ ,
?uu, -
.uu- .
ToStringuu. 6
(uu6 7
)uu7 8
;uu8 9
ifvv 

(vv 
stringvv 
.vv 
IsNullOrEmptyvv  
(vv  !
jsonContentvv! ,
)vv, -
)vv- .
returnww 
;ww 
varzz 
uniqueValueszz 
=zz 
ExtractUniqueValueszz .
(zz. /
jsonContentzz/ :
,zz: ;

enumConfigzz< F
.zzF G
FieldzzG L
)zzL M
;zzM N
if|| 

(|| 
!|| 
uniqueValues|| 
.|| 
Any|| 
(|| 
)|| 
)||  
{}} 	
context~~ 
.~~ 
ReportDiagnostic~~ $
(~~$ %

Diagnostic~~% /
.~~/ 0
Create~~0 6
(~~6 7
new  
DiagnosticDescriptor (
(( )
$str
€€ 
,
€€ 
$str
 %
,
% &
$"
‚‚ 
$str
‚‚ 1
{
‚‚1 2

enumConfig
‚‚2 <
.
‚‚< =
Field
‚‚= B
}
‚‚B C
$str
‚‚C P
{
‚‚P Q

enumConfig
‚‚Q [
.
‚‚[ \
Source
‚‚\ b
}
‚‚b c
$str
‚‚c l
{
‚‚l m

enumConfig
‚‚m w
.
‚‚w x
EnumName‚‚x €
}‚‚€ 
$str‚‚ ƒ
"‚‚ƒ „
,‚‚„ …
$str
ƒƒ +
,
ƒƒ+ , 
DiagnosticSeverity
„„ &
.
„„& '
Warning
„„' .
,
„„. /
true
…… 
)
…… 
,
…… 
Location
†† 
.
†† 
None
†† 
)
†† 
)
†† 
;
††  
return
‡‡ 
;
‡‡ 
}
ˆˆ 	
var
‹‹ 
source
‹‹ 
=
‹‹  
GenerateEnumSource
‹‹ '
(
‹‹' (

enumConfig
‹‹( 2
,
‹‹2 3
uniqueValues
‹‹4 @
)
‹‹@ A
;
‹‹A B
context
ŒŒ 
.
ŒŒ 
	AddSource
ŒŒ 
(
ŒŒ 
$"
ŒŒ 
{
ŒŒ 

enumConfig
ŒŒ '
.
ŒŒ' (
EnumName
ŒŒ( 0
}
ŒŒ0 1
$str
ŒŒ1 6
"
ŒŒ6 7
,
ŒŒ7 8
source
ŒŒ9 ?
)
ŒŒ? @
;
ŒŒ@ A
}
 
private
 
static
 
AdditionalText
 !
?
! "
FindJsonFile
# /
(
/ 0
ImmutableArray
0 >
<
> ?
AdditionalText
? M
>
M N
	jsonFiles
O X
,
X Y
string
Z `

sourceName
a k
)
k l
{
 
return
‘‘ 
	jsonFiles
‘‘ 
.
‘‘ 
FirstOrDefault
‘‘ '
(
‘‘' (
f
‘‘( )
=>
‘‘* ,
{
’’ 	
var
““ 
fileName
““ 
=
““ 
Path
““ 
.
““  )
GetFileNameWithoutExtension
““  ;
(
““; <
f
““< =
.
““= >
Path
““> B
)
““B C
;
““C D
var
”” 
fullPath
”” 
=
”” 
f
”” 
.
”” 
Path
”” !
;
””! "
if
—— 
(
—— 
fileName
—— 
.
—— 
Equals
—— 
(
——  

sourceName
——  *
,
——* +
StringComparison
——, <
.
——< =
OrdinalIgnoreCase
——= N
)
——N O
)
——O P
return
˜˜ 
true
˜˜ 
;
˜˜ 
if
›› 
(
›› 
fullPath
›› 
.
›› 
Contains
›› !
(
››! "
$"
››" $
$str
››$ %
{
››% &

sourceName
››& 0
}
››0 1
$str
››1 2
"
››2 3
)
››3 4
&&
››5 7
fileName
››8 @
.
››@ A
Equals
››A G
(
››G H

sourceName
››H R
,
››R S
StringComparison
››T d
.
››d e
OrdinalIgnoreCase
››e v
)
››v w
)
››w x
return
œœ 
true
œœ 
;
œœ 
if
ŸŸ 
(
ŸŸ 
fullPath
ŸŸ 
.
ŸŸ 
Contains
ŸŸ !
(
ŸŸ! "
$"
ŸŸ" $
$str
ŸŸ$ %
{
ŸŸ% &

sourceName
ŸŸ& 0
.
ŸŸ0 1
Replace
ŸŸ1 8
(
ŸŸ8 9
$str
ŸŸ9 E
,
ŸŸE F
$str
ŸŸG I
)
ŸŸI J
}
ŸŸJ K
$str
ŸŸK L
"
ŸŸL M
)
ŸŸM N
&&
ŸŸO Q
fileName
ŸŸR Z
.
ŸŸZ [
Equals
ŸŸ[ a
(
ŸŸa b

sourceName
ŸŸb l
,
ŸŸl m
StringComparison
ŸŸn ~
.
ŸŸ~  
OrdinalIgnoreCaseŸŸ 
)ŸŸ ‘
)ŸŸ‘ ’
return
   
true
   
;
   
return
¢¢ 
false
¢¢ 
;
¢¢ 
}
££ 	
)
££	 

;
££
 
}
¤¤ 
private
§§ 
static
§§ 
List
§§ 
<
§§ 
string
§§ 
>
§§ !
ExtractUniqueValues
§§  3
(
§§3 4
string
§§4 :
jsonContent
§§; F
,
§§F G
string
§§H N
	fieldName
§§O X
)
§§X Y
{
¨¨ 
var
©© 
values
©© 
=
©© 
new
©© 
HashSet
©©  
<
©©  !
string
©©! '
>
©©' (
(
©©( )
)
©©) *
;
©©* +
var
¬¬ 
pattern
¬¬ 
=
¬¬ 
$"
¬¬ 
$str
¬¬ 
{
¬¬ 
Regex
¬¬  
.
¬¬  !
Escape
¬¬! '
(
¬¬' (
	fieldName
¬¬( 1
)
¬¬1 2
}
¬¬2 3
$str
¬¬3 J
"
¬¬J K
;
¬¬K L
var
­­ 
matches
­­ 
=
­­ 
Regex
­­ 
.
­­ 
Matches
­­ #
(
­­# $
jsonContent
­­$ /
,
­­/ 0
pattern
­­1 8
)
­­8 9
;
­­9 :
foreach
¯¯ 
(
¯¯ 
Match
¯¯ 
match
¯¯ 
in
¯¯ 
matches
¯¯  '
)
¯¯' (
{
°° 	
if
±± 
(
±± 
match
±± 
.
±± 
Groups
±± 
.
±± 
Count
±± "
>
±±# $
$num
±±% &
)
±±& '
{
²² 
var
³³ 
value
³³ 
=
³³ 
match
³³ !
.
³³! "
Groups
³³" (
[
³³( )
$num
³³) *
]
³³* +
.
³³+ ,
Value
³³, 1
;
³³1 2
if
´´ 
(
´´ 
!
´´ 
string
´´ 
.
´´ 
IsNullOrEmpty
´´ )
(
´´) *
value
´´* /
)
´´/ 0
)
´´0 1
{
µµ 
values
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
value
¶¶ $
)
¶¶$ %
;
¶¶% &
}
·· 
}
¸¸ 
}
¹¹ 	
return
»» 
values
»» 
.
»» 
OrderBy
»» 
(
»» 
v
»» 
=>
»»  "
v
»»# $
)
»»$ %
.
»»% &
ToList
»»& ,
(
»», -
)
»»- .
;
»». /
}
¼¼ 
private
¾¾ 
static
¾¾ 
string
¾¾  
GenerateEnumSource
¾¾ ,
(
¾¾, -

EnumConfig
¾¾- 7

enumConfig
¾¾8 B
,
¾¾B C
List
¾¾D H
<
¾¾H I
string
¾¾I O
>
¾¾O P
values
¾¾Q W
)
¾¾W X
{
¿¿ 
var
ÀÀ 
sb
ÀÀ 
=
ÀÀ 
new
ÀÀ 
StringBuilder
ÀÀ "
(
ÀÀ" #
)
ÀÀ# $
;
ÀÀ$ %
sb
ÂÂ 

.
ÂÂ
 

AppendLine
ÂÂ 
(
ÂÂ 
$str
ÂÂ -
)
ÂÂ- .
;
ÂÂ. /
sb
ÃÃ 

.
ÃÃ
 

AppendLine
ÃÃ 
(
ÃÃ 
$"
ÃÃ 
$str
ÃÃ *
{
ÃÃ* +

enumConfig
ÃÃ+ 5
.
ÃÃ5 6
Source
ÃÃ6 <
}
ÃÃ< =
$str
ÃÃ= K
{
ÃÃK L

enumConfig
ÃÃL V
.
ÃÃV W
Field
ÃÃW \
}
ÃÃ\ ]
"
ÃÃ] ^
)
ÃÃ^ _
;
ÃÃ_ `
sb
ÄÄ 

.
ÄÄ
 

AppendLine
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
sb
ÅÅ 

.
ÅÅ
 

AppendLine
ÅÅ 
(
ÅÅ 
$str
ÅÅ H
)
ÅÅH I
;
ÅÅI J
sb
ÆÆ 

.
ÆÆ
 

AppendLine
ÆÆ 
(
ÆÆ 
)
ÆÆ 
;
ÆÆ 
sb
ÇÇ 

.
ÇÇ
 

AppendLine
ÇÇ 
(
ÇÇ 
$"
ÇÇ 
$str
ÇÇ $
{
ÇÇ$ %

enumConfig
ÇÇ% /
.
ÇÇ/ 0
EnumName
ÇÇ0 8
}
ÇÇ8 9
"
ÇÇ9 :
)
ÇÇ: ;
;
ÇÇ; <
sb
ÈÈ 

.
ÈÈ
 

AppendLine
ÈÈ 
(
ÈÈ 
$str
ÈÈ 
)
ÈÈ 
;
ÈÈ 
for
ÊÊ 
(
ÊÊ 
int
ÊÊ 
i
ÊÊ 
=
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
i
ÊÊ 
<
ÊÊ 
values
ÊÊ "
.
ÊÊ" #
Count
ÊÊ# (
;
ÊÊ( )
i
ÊÊ* +
++
ÊÊ+ -
)
ÊÊ- .
{
ËË 	
var
ÌÌ 
value
ÌÌ 
=
ÌÌ 
values
ÌÌ 
[
ÌÌ 
i
ÌÌ  
]
ÌÌ  !
;
ÌÌ! "
var
ÍÍ 

enumMember
ÍÍ 
=
ÍÍ  
SanitizeEnumMember
ÍÍ /
(
ÍÍ/ 0
value
ÍÍ0 5
)
ÍÍ5 6
;
ÍÍ6 7
sb
ÏÏ 
.
ÏÏ 
Append
ÏÏ 
(
ÏÏ 
$"
ÏÏ 
$str
ÏÏ 
{
ÏÏ 

enumMember
ÏÏ '
}
ÏÏ' (
"
ÏÏ( )
)
ÏÏ) *
;
ÏÏ* +
if
ĞĞ 
(
ĞĞ 
i
ĞĞ 
<
ĞĞ 
values
ĞĞ 
.
ĞĞ 
Count
ĞĞ  
-
ĞĞ! "
$num
ĞĞ# $
)
ĞĞ$ %
sb
ÑÑ 
.
ÑÑ 
Append
ÑÑ 
(
ÑÑ 
$str
ÑÑ 
)
ÑÑ 
;
ÑÑ 
sb
ÒÒ 
.
ÒÒ 

AppendLine
ÒÒ 
(
ÒÒ 
)
ÒÒ 
;
ÒÒ 
}
ÓÓ 	
sb
ÕÕ 

.
ÕÕ
 

AppendLine
ÕÕ 
(
ÕÕ 
$str
ÕÕ 
)
ÕÕ 
;
ÕÕ 
return
×× 
sb
×× 
.
×× 
ToString
×× 
(
×× 
)
×× 
;
×× 
}
ØØ 
private
ÚÚ 
static
ÚÚ 
string
ÚÚ  
SanitizeEnumMember
ÚÚ ,
(
ÚÚ, -
string
ÚÚ- 3
value
ÚÚ4 9
)
ÚÚ9 :
{
ÛÛ 
if
ÜÜ 

(
ÜÜ 
string
ÜÜ 
.
ÜÜ 
IsNullOrEmpty
ÜÜ  
(
ÜÜ  !
value
ÜÜ! &
)
ÜÜ& '
)
ÜÜ' (
return
İİ 
$str
İİ 
;
İİ 
var
àà 
parts
àà 
=
àà 
value
àà 
.
àà 
Split
àà 
(
àà  
new
àà  #
[
àà# $
]
àà$ %
{
àà& '
$char
àà( +
}
àà, -
,
àà- . 
StringSplitOptions
àà/ A
.
ààA B 
RemoveEmptyEntries
ààB T
)
ààT U
;
ààU V
var
áá 
result
áá 
=
áá 
new
áá 
StringBuilder
áá &
(
áá& '
)
áá' (
;
áá( )
foreach
ãã 
(
ãã 
var
ãã 
part
ãã 
in
ãã 
parts
ãã "
)
ãã" #
{
ää 	
if
åå 
(
åå 
part
åå 
.
åå 
Length
åå 
>
åå 
$num
åå 
)
åå  
{
ææ 
result
èè 
.
èè 
Append
èè 
(
èè 
char
èè "
.
èè" #
ToUpperInvariant
èè# 3
(
èè3 4
part
èè4 8
[
èè8 9
$num
èè9 :
]
èè: ;
)
èè; <
)
èè< =
;
èè= >
if
éé 
(
éé 
part
éé 
.
éé 
Length
éé 
>
éé  !
$num
éé" #
)
éé# $
{
êê 
result
ëë 
.
ëë 
Append
ëë !
(
ëë! "
part
ëë" &
.
ëë& '
	Substring
ëë' 0
(
ëë0 1
$num
ëë1 2
)
ëë2 3
.
ëë3 4
ToLowerInvariant
ëë4 D
(
ëëD E
)
ëëE F
)
ëëF G
;
ëëG H
}
ìì 
}
íí 
}
îî 	
var
ğğ 
finalResult
ğğ 
=
ğğ 
result
ğğ  
.
ğğ  !
ToString
ğğ! )
(
ğğ) *
)
ğğ* +
;
ğğ+ ,
if
óó 

(
óó 
finalResult
óó 
.
óó 
Length
óó 
>
óó  
$num
óó! "
&&
óó# %
char
óó& *
.
óó* +
IsDigit
óó+ 2
(
óó2 3
finalResult
óó3 >
[
óó> ?
$num
óó? @
]
óó@ A
)
óóA B
)
óóB C
{
ôô 	
finalResult
õõ 
=
õõ 
$str
õõ 
+
õõ 
finalResult
õõ  +
;
õõ+ ,
}
öö 	
return
øø 
string
øø 
.
øø 
IsNullOrEmpty
øø #
(
øø# $
finalResult
øø$ /
)
øø/ 0
?
øø1 2
$str
øø3 =
:
øø> ?
finalResult
øø@ K
;
øøK L
}
ùù 
private
ûû 
class
ûû 

EnumConfig
ûû 
{
üü 
public
ıı 
string
ıı 
EnumName
ıı 
{
ıı  
get
ıı! $
;
ıı$ %
}
ıı& '
public
şş 
string
şş 
Source
şş 
{
şş 
get
şş "
;
şş" #
}
şş$ %
public
ÿÿ 
string
ÿÿ 
Field
ÿÿ 
{
ÿÿ 
get
ÿÿ !
;
ÿÿ! "
}
ÿÿ# $
public
 

EnumConfig
 
(
 
string
  
enumName
! )
,
) *
string
+ 1
source
2 8
,
8 9
string
: @
field
A F
)
F G
{
‚‚ 	
EnumName
ƒƒ 
=
ƒƒ 
enumName
ƒƒ 
;
ƒƒ  
Source
„„ 
=
„„ 
source
„„ 
;
„„ 
Field
…… 
=
…… 
field
…… 
;
…… 
}
†† 	
}
‡‡ 
}ˆˆ 